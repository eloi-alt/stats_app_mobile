<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TrueCircle Mobile</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: #222;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        /* iPhone 15 Pro Mockup - Restored */
        #iphone-frame {
            position: relative;
            width: 393px;
            height: 852px;
            background: #000;
            border-radius: 55px;
            border: 12px solid #000;
            /* The Bezel */
            box-shadow:
                0 0 0 2px #3a3a3a,
                /* Inner Titanium edge */
                0 0 0 4px #242424,
                /* Outer Titanium edge */
                0 30px 60px rgba(0, 0, 0, 0.6);
            /* Depth shadow */
            overflow: hidden;
            box-sizing: border-box;
            transform-origin: center center;
        }

        /* Responsive scaling */
        @media (max-height: 900px) {
            #iphone-frame {
                transform: scale(0.9);
            }
        }

        @media (max-height: 800px) {
            #iphone-frame {
                transform: scale(0.8);
            }
        }

        /* Dynamic Island - HIDDEN PER USER REQUEST */
        #dynamic-island {
            display: none;
        }

        /* Home Indicator relative to frame */
        #home-indicator {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 134px;
            height: 5px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            z-index: 100;
        }

        /* App Screen Container */
        #app-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #FFFFFF;
            overflow: hidden;
            border-radius: 43px;
        }

        /* Canvas */
        #viz-canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        /* Search Bar */
        #search-bar {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            margin-top: 10px;
            left: 16px;
            right: 120px;
            /* Space for FABs */
            /* Space for FAB */
            height: 44px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 22px;
            /* Pill shape */
            display: flex;
            align-items: center;
            padding: 0 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            z-index: 50;
            transition: all 0.3s ease;
        }

        #search-clear {
            display: none;
            width: 24px;
            height: 24px;
            margin-left: 8px;
            color: rgba(0, 0, 0, 0.5);
            cursor: pointer;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.05);
            text-align: center;
            line-height: 24px;
            font-size: 14px;
        }

        #search-bar input {
            flex: 1;
            border: none;
            background: transparent;
            font-size: 16px;
            color: #000;
            outline: none;
            font-family: inherit;
            min-width: 0;
        }

        #search-icon {
            color: rgba(0, 0, 0, 0.4);
            margin-right: 10px;
            width: 20px;
            height: 20px;
            fill: currentColor;
            flex-shrink: 0;
        }

        /* Settings FAB */
        #settings-fab {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            margin-top: 10px;
            right: 16px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            z-index: 51;
            cursor: pointer;
        }

        #settings-fab svg {
            width: 24px;
            height: 24px;
            fill: rgba(0, 0, 0, 0.7);
        }

        /* Magic Wand FAB (Timelapse) */
        #timelapse-fab {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            margin-top: 10px;
            right: 70px;
            /* Left of settings (16px + 44px + 10px gap) */
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            z-index: 51;
            cursor: pointer;
        }

        #timelapse-fab svg {
            width: 24px;
            height: 24px;
            fill: rgba(0, 0, 0, 0.7);
        }

        /* Magic Wand FAB (Timelapse) */
        #timelapse-fab {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            margin-top: 10px;
            right: 70px;
            /* Left of settings (16px + 44px + 10px gap) */
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            z-index: 51;
            cursor: pointer;
        }

        #timelapse-fab svg {
            width: 24px;
            height: 24px;
            fill: rgba(0, 0, 0, 0.7);
        }

        /* Bottom Sheet - Restored Prettier Style */
        .sheet-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.85);
            /* Restored blur effect base */
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            border-radius: 20px 20px 0 0;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            /* Faster default transition */
            z-index: 300;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.1);
        }

        .sheet-container.dragging {
            transition: none;
            /* No transition while dragging */
        }

        .sheet-container.visible {
            transform: translateY(0);
        }

        #bottom-sheet {
            height: 75%;
            z-index: 200;
        }

        #modal-sheet {
            height: 75%;
            z-index: 300;
        }

        .sheet-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 199;
        }

        .sheet-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #modal-overlay {
            z-index: 299;
        }

        /* Draggable Area */
        .sheet-header-area {
            padding-top: 8px;
            padding-bottom: 0px;
            cursor: grab;
        }

        .sheet-grabber {
            width: 36px;
            height: 5px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
            margin: 8px auto 16px;
            flex-shrink: 0;
        }

        .sheet-content {
            padding: 0 20px 34px;
            overflow-y: auto;
            flex: 1;
        }

        .sheet-title {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 24px;
            color: #000;
        }

        .sheet-section {
            margin-bottom: 28px;
        }

        .sheet-section-title {
            font-size: 13px;
            font-weight: 600;
            color: rgba(0, 0, 0, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        /* iOS Toggle */
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
            min-height: 44px;
        }

        .toggle-label {
            font-size: 17px;
            color: #000;
        }

        .ios-switch {
            position: relative;
            width: 51px;
            height: 31px;
            flex-shrink: 0;
        }

        .ios-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .ios-switch .slider {
            position: absolute;
            /* ... */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(120, 120, 128, 0.16);
            transition: 0.3s;
            border-radius: 31px;
        }

        .ios-switch .slider:before {
            position: absolute;
            content: "";
            height: 27px;
            width: 27px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
        }

        .ios-switch input:checked+.slider {
            background-color: #34C759;
        }

        .ios-switch input:checked+.slider:before {
            transform: translateX(20px);
        }

        /* Sliders */
        .slider-row {
            padding: 16px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .slider-label {
            font-size: 17px;
        }

        .slider-value {
            font-size: 15px;
            color: rgba(0, 0, 0, 0.5);
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 28px;
            height: 28px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
        }

        /* Modal Content */
        .modal-content {
            text-align: center;
        }

        .modal-photo {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            object-fit: cover;
            margin: 10px auto 20px;
            display: block;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .modal-name {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
        }

        .modal-info-row {
            display: flex;
            justify-content: space-between;
            padding: 14px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
            text-align: left;
        }

        .modal-info-label {
            font-size: 15px;
            color: rgba(0, 0, 0, 0.5);
        }

        .modal-info-value {
            font-size: 15px;
            font-weight: 600;
            color: #000;
        }

        .action-button {
            display: block;
            width: 100%;
            margin-top: 20px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.06);
            border-radius: 12px;
            font-size: 17px;
            font-weight: 600;
            color: #000;
            text-decoration: none;
            text-align: center;
        }

        /* Common Connections */
        .common-connections-section {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
        }

        .common-connections-label {
            font-size: 13px;
            font-weight: 600;
            color: rgba(0, 0, 0, 0.5);
            margin-bottom: 12px;
            text-align: left;
        }

        .common-connections-list {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding-bottom: 8px;
            -webkit-overflow-scrolling: touch;
        }

        .common-connection-item {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        .common-connection-photo {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            object-fit: cover;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
        }

        .common-connection-name {
            font-size: 12px;
            color: rgba(0, 0, 0, 0.7);
            margin-top: 6px;
            max-width: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Connection Modal Photos */
        .connection-photos-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0 20px;
        }

        .connection-photo-container {
            cursor: pointer;
        }

        .connection-photo {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }

        .connection-photo:hover {
            transform: scale(1.05);
        }

        /* Search Results */
        #search-results {
            position: absolute;
            top: calc(max(20px, env(safe-area-inset-top)) + 60px);
            left: 16px;
            right: 16px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.12);
            z-index: 52;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }

        #search-results.visible {
            display: block;
        }

        .search-result-item {
            padding: 14px 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
            cursor: pointer;
        }

        .search-result-name {
            font-size: 17px;
            font-weight: 500;
        }

        .search-result-meta {
            font-size: 13px;
            color: rgba(0, 0, 0, 0.5);
        }

        /* Connection Photos */
        .connection-photos-row {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin: 20px 0;
        }

        .connection-photo-container {
            position: relative;
            width: 80px;
            height: 80px;
        }

        .connection-photo {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Timelapse Date Display */
        #timelapse-date-display {
            position: absolute;
            top: 110px;
            /* Moved down to avoid potential overlaps */
            right: 20px;
            font-size: 24px;
            font-weight: 700;
            color: rgba(0, 0, 0, 0.8);
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(15px);
            padding: 8px 16px;
            border-radius: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 50;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>

<body>
    <div id="iphone-frame">
        <div id="dynamic-island"></div>
        <div id="home-indicator"></div>

        <div id="app-screen">
            <canvas id="viz-canvas"></canvas>

            <!-- Search Bar -->
            <div id="search-bar">
                <svg id="search-icon" viewBox="0 0 24 24">
                    <path
                        d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
                </svg>
                <input type="text" id="search-input" placeholder="Rechercher...">
                <div id="search-clear">✕</div>
            </div>

            <div id="search-results"></div>

            <!-- Timelapse Stopwatch Button -->
            <div id="timelapse-fab" onclick="toggleTimelapse()">
                <!-- Stopwatch Icon -->
                <svg viewBox="0 0 24 24">
                    <path
                        d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z" />
                </svg>
            </div>

            <!-- Timelapse Date Display -->
            <div id="timelapse-date-display">Nov 2024</div>

            <!-- Settings FAB -->
            <div id="settings-fab">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.49l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.43-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.08-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z" />
                </svg>
            </div>

            <div id="bottom-sheet-overlay" class="sheet-overlay"></div>

            <div id="bottom-sheet" class="sheet-container">
                <div class="sheet-header-area">
                    <div class="sheet-grabber"></div>
                </div>
                <div class="sheet-content">
                    <div class="sheet-title">Réglages</div>
                    <!-- Groups -->
                    <div class="sheet-section">
                        <div class="sheet-section-title">Groupes</div>
                        <div class="toggle-row">
                            <span class="toggle-label">Famille</span>
                            <label class="ios-switch">
                                <input type="checkbox" id="group-family" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="toggle-row">
                            <span class="toggle-label">Travail</span>
                            <label class="ios-switch">
                                <input type="checkbox" id="group-work" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="toggle-row">
                            <span class="toggle-label">Amis</span>
                            <label class="ios-switch">
                                <input type="checkbox" id="group-friends" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <!-- Display -->
                    <div class="sheet-section">
                        <div class="sheet-section-title">Affichage</div>
                        <div class="toggle-row">
                            <span class="toggle-label">Noms</span>
                            <label class="ios-switch">
                                <input type="checkbox" id="show-names" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="toggle-row">
                            <span class="toggle-label">Connexions</span>
                            <label class="ios-switch">
                                <input type="checkbox" id="show-connections" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="toggle-row">
                            <span class="toggle-label">Liens centre</span>
                            <label class="ios-switch">
                                <input type="checkbox" id="show-center-links" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="toggle-row">
                            <span class="toggle-label">Labels conn.</span>
                            <label class="ios-switch">
                                <input type="checkbox" id="show-connection-labels" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <!-- Params -->
                    <div class="sheet-section">
                        <div class="sheet-section-title">Paramètres</div>
                        <div class="slider-row">
                            <div class="slider-header">
                                <span class="slider-label">Profondeur</span>
                                <span class="slider-value" id="rank-value">1</span>
                            </div>
                            <input type="range" id="rank-range" min="1" max="5" value="1">
                        </div>
                        <div class="slider-row">
                            <div class="slider-header">
                                <span class="slider-label">Densité</span>
                                <span class="slider-value" id="density-value">50%</span>
                            </div>
                            <input type="range" id="density-range" min="0" max="100" value="50">
                        </div>
                        <div class="slider-row">
                            <div class="slider-header">
                                <span class="slider-label">Taille points</span>
                                <span class="slider-value" id="node-size-value">100%</span>
                            </div>
                            <input type="range" id="node-size-range" min="50" max="250" value="100">
                        </div>
                        <div class="slider-row">
                            <div class="slider-header">
                                <span class="slider-label">Épaisseur liens</span>
                                <span class="slider-value" id="link-width-value">200%</span>
                            </div>
                            <input type="range" id="link-width-range" min="10" max="500" value="200">
                        </div>
                    </div>
                    <!-- Filters -->
                    <div class="sheet-section">
                        <div class="sheet-section-title">Filtres</div>
                        <div class="toggle-row">
                            <span class="toggle-label">Par âge (20 ans)</span>
                            <label class="ios-switch">
                                <input type="checkbox" id="filter-by-age">
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="toggle-row">
                            <span class="toggle-label">Plus anciens</span>
                            <label class="ios-switch">
                                <input type="checkbox" id="filter-oldest">
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="toggle-row">
                            <span class="toggle-label">Plus récents</span>
                            <label class="ios-switch">
                                <input type="checkbox" id="filter-most-recent">
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="toggle-row">
                            <span class="toggle-label">Orphelins</span>
                            <label class="ios-switch">
                                <input type="checkbox" id="filter-orphans">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <div id="modal-overlay" class="sheet-overlay"></div>

            <div id="modal-sheet" class="sheet-container">
                <div class="sheet-grabber"></div>
                <div class="modal-content sheet-content" id="modal-content">
                    <!-- Dynamic content -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. CONFIGURATION & DATA
        // ==========================================
        const ELOI_DATA = { name: "ELOI", index: -1, layerRank: 0, age: 20, joinDate: "11/2024", imageName: "eloii", baseX: 0, baseY: 0, baseZ: 0, color: { r: 10, g: 10, b: 10 } };
        const ELOI_AGE = 20;

        let settings = {
            showNames: true, showConnections: true, showCenterLinks: true, showConnectionLabels: true,
            maxRank: 1, connectionDensity: 0.5, nodeSizeMultiplier: 1.0, linkThicknessMultiplier: 2.0, // Thicker default
            filterByAge: false, filterOldest: false, filterMostRecent: false, filterOrphans: false,
            groupFamily: true, groupWork: true, groupFriends: true, searchQuery: ''
        };

        let masterNodes = []; // Source of truth
        let sphereNodes = []; // Render array
        let isSearchMode = false;
        let previousRank = 1;
        let searchResultsNodes = [];
        let stableConnections = [];
        let connections = [];
        let connectionData = {};

        let oldestNodes = [];
        let mostRecentNodes = [];

        let centerNode = { baseX: 0, baseY: 0, baseZ: 0 };
        const baseRadius = 110;

        // Interaction State
        let currentRotation = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let zoomLevel = 1.0;
        let targetZoom = 1.0;

        let isDragging = false;
        let touchStartX = 0, touchStartY = 0;
        let lastTouchX = 0, lastTouchY = 0;
        let hasMoved = false;
        let initialPinchDistance = 0;
        let initialZoom = 1.0;
        let vizOffset = { x: 0, y: 0 };
        let lastPinchCenterX = undefined;
        let lastPinchCenterY = undefined;
        let initialPinchMidpoint = { x: 0, y: 0 };
        let gestureMode = null; // 'pan' or 'zoom'

        let isSettingsOpen = false;
        let isModalOpen = false;
        let autoRotating = true; // Auto-rotate by default on mobile
        let autoRotationAngle = 0;

        let clickedNodeIndex = -2;
        let clickedConnectionKey = null;
        let isCenterClicked = false;
        let hoveredNodeIndex = -1;
        let hoveredConnection = null;
        let isHoveringCenter = false;

        const europeanNames = [
            "Sophie", "Lucas", "Emma", "Thomas", "Léa", "Hugo", "Camille", "Antoine", "Marie", "Pierre",
            "Julie", "Nicolas", "Claire", "Alexandre", "Sarah", "Maxime", "Laura", "Julien", "Manon", "Romain",
            "Chloé", "Baptiste", "Élise", "Vincent", "Anaïs", "Matthieu", "Pauline", "Sébastien", "Marion", "Guillaume",
            "Amélie", "Florian", "Lucie", "Adrien", "Justine", "Raphaël", "Émilie", "Benjamin", "Céline", "Jérôme"
        ];

        const vizCanvas = document.getElementById('viz-canvas');
        const vizCtx = vizCanvas.getContext('2d');
        let vizWidth, vizHeight;

        // ==========================================
        // 2. CORE LOGIC (Restored from truecircle_gemini.html)
        // ==========================================

        function resizeViz() {
            const screen = document.getElementById('app-screen');
            vizWidth = vizCanvas.width = screen.clientWidth;
            vizHeight = vizCanvas.height = screen.clientHeight;
        }
        window.addEventListener('resize', resizeViz);
        resizeViz();

        function getLayerInfoForRank(rank) {
            const counts = { 1: 10, 2: 40, 3: 100, 4: 400, 5: 1500 };
            const inc = 45;
            let layers = [];
            for (let r = 1; r <= rank; r++) { layers.push({ nodeCount: counts[r] || 40, radius: baseRadius + (r - 1) * inc, rank: r }); }
            return layers;
        }

        function initTrueCircle() {
            // Generate ALL nodes (Rank 1-5) once into MASTER
            let existing = [...masterNodes];
            masterNodes = [];
            // Always generate up to rank 5 for global search
            const layers = getLayerInfoForRank(5);
            connectionData = {};
            stableConnections = [];

            let globalIndex = 0;
            layers.forEach(layer => {
                for (let i = 0; i < layer.nodeCount; i++) {
                    let phi = Math.acos(-1 + (2 * i) / layer.nodeCount);
                    let theta = Math.sqrt(layer.nodeCount * Math.PI) * phi;
                    let radius = layer.radius;

                    let nodeData;
                    if (existing[globalIndex]) {
                        nodeData = {
                            ...existing[globalIndex],
                            baseX: radius * Math.cos(theta) * Math.sin(phi),
                            baseY: radius * Math.sin(theta) * Math.sin(phi),
                            baseZ: radius * Math.cos(phi),
                            originalX: radius * Math.cos(theta) * Math.sin(phi),
                            originalY: radius * Math.sin(theta) * Math.sin(phi),
                            originalZ: radius * Math.cos(phi),
                            layerRank: layer.rank, index: globalIndex, isOrphan: true
                        };
                    } else {
                        // Logic for Parents (first 2 nodes of Rank 1)
                        let isParent = (layer.rank === 1 && globalIndex < 2);

                        let r = Math.random() * 40, g = Math.random() * 40, b = Math.random() * 40;
                        if (Math.random() > 0.5) { r = 0; g = 0; }
                        nodeData = {
                            baseX: radius * Math.cos(theta) * Math.sin(phi),
                            baseY: radius * Math.sin(theta) * Math.sin(phi),
                            baseZ: radius * Math.cos(phi),
                            originalX: radius * Math.cos(theta) * Math.sin(phi),
                            originalY: radius * Math.sin(theta) * Math.sin(phi),
                            originalZ: radius * Math.cos(phi),
                            color: { r: 10 + Math.random() * 50, g: 10 + Math.random() * 50, b: 10 + Math.random() * 50 },
                            name: isParent ? (globalIndex === 0 ? "Maman" : "Papa") : europeanNames[globalIndex % europeanNames.length],
                            layerRank: layer.rank,
                            index: globalIndex,
                            group: isParent ? 'FAMILY' : ['FAMILY', 'WORK', 'FRIENDS'][globalIndex % 3],
                            age: isParent ? 50 : (20 + ((globalIndex * 7919) % 40)),
                            isOrphan: true,
                            connectionDate: isParent ? generateParentDate() : generateConnectionDate(layer.rank)
                        };
                    }
                    masterNodes.push(nodeData);
                    globalIndex++;
                }
            });

            // Sort masterNodes by date for timelapse order (Oldest first)
            masterNodes.sort((a, b) => a.connectionDate - b.connectionDate);
            // Re-index after sort to keep index consistent with array position
            masterNodes.forEach((n, i) => n.index = i);

            // Initialize sphereNodes with masterNodes
            sphereNodes = [...masterNodes];

            identifyOrphans();
            calculateAgeFilters();
        }

        function generateParentDate() {
            // Parents connected at birth (20 years ago)
            const now = new Date();
            const date = new Date(now);
            date.setFullYear(now.getFullYear() - 20);
            date.setMonth(0); // Jan
            date.setDate(1);
            return date;
        }

        function generateConnectionDate(rank) {
            const now = new Date();
            const currentYear = now.getFullYear();
            const birthYear = currentYear - 20;

            // Ensure NO ONE is older than parents (20 years ago)
            // Random connections start from 19 years ago max
            let minYearsAgo, maxYearsAgo;

            if (rank === 1) { minYearsAgo = 10; maxYearsAgo = 19; }
            else if (rank === 2) { minYearsAgo = 5; maxYearsAgo = 12; }
            else if (rank === 3) { minYearsAgo = 2; maxYearsAgo = 8; }
            else { minYearsAgo = 0; maxYearsAgo = 5; }

            const yearsAgo = minYearsAgo + Math.random() * (maxYearsAgo - minYearsAgo);
            const date = new Date(now);
            let year = currentYear - Math.floor(yearsAgo);

            // Safety
            if (year < birthYear) year = birthYear + 1;

            date.setFullYear(year);
            date.setMonth(Math.floor(Math.random() * 12));
            date.setDate(Math.floor(Math.random() * 28) + 1);

            // STRICT CAP at current date
            if (date > now) {
                date.setTime(now.getTime() - Math.random() * 86400000); // Set to yesterday/today random
            }
            return date;
        }

        function identifyOrphans() {
            sphereNodes.forEach(n => n.isOrphan = true);
            stableConnections.forEach(c => {
                if (c.data.rank <= settings.maxRank) {
                    if (sphereNodes[c.data.index1]) sphereNodes[c.data.index1].isOrphan = false;
                    if (sphereNodes[c.data.index2]) sphereNodes[c.data.index2].isOrphan = false;
                }
            });
        }

        function calculateAgeFilters() {
            if (!sphereNodes.length) return;
            let sorted = [...sphereNodes].sort((a, b) => b.age - a.age);
            oldestNodes = sorted.slice(0, Math.ceil(sphereNodes.length * 0.2)).map(n => n.index);
            mostRecentNodes = sorted.slice(-Math.ceil(sphereNodes.length * 0.2)).map(n => n.index);
        }

        function isNodeVisible(node) {
            if (!settings.groupFamily && node.group === 'FAMILY') return false;
            if (!settings.groupWork && node.group === 'WORK') return false;
            if (!settings.groupFriends && node.group === 'FRIENDS') return false;
            if (settings.filterByAge && Math.abs(node.age - ELOI_AGE) > 1) return false;
            if (node.layerRank > settings.maxRank && node.index !== -1) return false;

            if (settings.filterOldest && !oldestNodes.includes(node.index)) return false;
            if (settings.filterMostRecent && !mostRecentNodes.includes(node.index)) return false;
            if (settings.filterOrphans && !node.isOrphan) return false;
            if (settings.searchQuery && !node.name.toLowerCase().includes(settings.searchQuery.toLowerCase())) return false;
            return true;
        }

        // ==========================================
        // 3. IMAGES & HELPERS
        // ==========================================
        const labelImageCache = {};
        function nameToFilename(name) {
            return name.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-zA-Z0-9]/g, "");
        }
        function getLabelImage(node) {
            if (!node) return null;
            let clean = node.index === -1 ? ELOI_DATA.imageName : nameToFilename(node.name);
            if (labelImageCache[node.index]) return labelImageCache[node.index];
            if (labelImageCache[node.index] === undefined) {
                labelImageCache[node.index] = null;
                let img = new Image();
                img.onload = () => labelImageCache[node.index] = img;
                img.src = `/truecircle/${clean}.jpg`;
            }
            return labelImageCache[node.index];
        }

        function toSuperscript(num) {
            const supers = { '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', '5': '⁵' };
            return supers[num] || '';
        }

        // Distance point to segment for connection hit detection
        function distancePointToSegment(px, py, x1, y1, x2, y2) {
            let A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
            let dot = A * C + B * D, lenSq = C * C + D * D;
            let param = lenSq !== 0 ? dot / lenSq : -1;
            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }
            return Math.sqrt((px - xx) ** 2 + (py - yy) ** 2);
        }

        // Connection regeneration flag
        let connectionsNeedUpdate = true;

        // WebSocket Server Connection
        const WS_URL = 'ws://192.168.1.6:3000';
        let socket = null;
        let reconnectTimeout = null;

        function connectToServer() {
            try {
                socket = new WebSocket(WS_URL);
                socket.onopen = () => console.log('Connected to server:', WS_URL);
                socket.onclose = () => {
                    console.log('Server disconnected, reconnecting in 5s...');
                    reconnectTimeout = setTimeout(connectToServer, 5000);
                };
                socket.onerror = (err) => console.log('WebSocket error:', err);
                socket.onmessage = (e) => {
                    try {
                        let data = JSON.parse(e.data);
                        console.log('Server message:', data);
                    } catch (err) { }
                };
            } catch (err) {
                console.log('Connection failed, retrying in 5s...');
                reconnectTimeout = setTimeout(connectToServer, 5000);
            }
        }
        connectToServer();

        // Get common connections for a node
        function getCommonConnections(nodeIndex) {
            let connections = [];
            stableConnections.forEach(conn => {
                if (conn.index1 === nodeIndex) {
                    let connNode = sphereNodes[conn.index2];
                    if (connNode) connections.push(connNode);
                } else if (conn.index2 === nodeIndex) {
                    let connNode = sphereNodes[conn.index1];
                    if (connNode) connections.push(connNode);
                }
            });
            return connections;
        }

        // ==========================================
        // 4. RENDERING LOOP (Restored Complex Logic)
        // ==========================================
        // LIQUID GLASS RENDERER
        // LIQUID GLASS RENDERER (OPTIMIZED)
        function drawLiquidBubble(ctx, x, y, radius, img) {
            // 1. FAKE DROP SHADOW (Performance Optimization)
            // context.shadowBlur is very expensive. We use a radial gradient instead.
            let shadowRadius = radius * 1.3;
            let shadowGrad = ctx.createRadialGradient(x, y + radius * 0.2, radius * 0.8, x, y + radius * 0.2, shadowRadius);
            shadowGrad.addColorStop(0, "rgba(75, 0, 130, 0.2)");
            shadowGrad.addColorStop(1, "rgba(75, 0, 130, 0)");

            ctx.fillStyle = shadowGrad;
            ctx.beginPath();
            ctx.arc(x, y + radius * 0.2, shadowRadius, 0, Math.PI * 2);
            ctx.fill();

            // Base Circle
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
            ctx.fill();

            // 2. IMAGE (Clearer)
            if (img) {
                let imgRadius = radius * 0.90;
                ctx.save();
                ctx.beginPath();
                ctx.arc(x, y, imgRadius, 0, Math.PI * 2);
                ctx.clip();
                ctx.drawImage(img, x - imgRadius, y - imgRadius, imgRadius * 2, imgRadius * 2);

                // Removed value-draining masks or overlays directly on image to keep it clear
                ctx.restore();
            }

            // 3. INNER SHADOWS & VOLUME (Reduced opacity for visibility)
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.clip();

            // Top-Left Light (Reduced alpha)
            let gradLight = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, radius * 0.1, x, y, radius);
            gradLight.addColorStop(0, "rgba(255, 255, 255, 0.2)"); // Reduced from 0.4
            gradLight.addColorStop(1, "rgba(255, 255, 255, 0)");
            ctx.fillStyle = gradLight;
            ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);

            // Bottom-Right Dark (Reduced alpha)
            let gradDark = ctx.createRadialGradient(x + radius * 0.4, y + radius * 0.4, radius * 0.1, x, y, radius * 1.2);
            gradDark.addColorStop(0, "rgba(0, 0, 0, 0.4)"); // Reduced from 0.6
            gradDark.addColorStop(1, "rgba(0, 0, 0, 0)");
            ctx.fillStyle = gradDark;
            ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);

            ctx.restore();

            // 4. BORDER
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.25)";
            ctx.lineWidth = 1;
            ctx.stroke();

            // 5. GLARE OVERLAY (Moved more to side/reduced)
            ctx.save();
            let gx = x - radius * 0.4;
            let gy = y - radius * 0.4;

            let glareGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, radius * 1.5);
            glareGrad.addColorStop(0, "rgba(255, 255, 255, 0.4)"); // Reduced from 0.7
            glareGrad.addColorStop(0.2, "rgba(255, 255, 255, 0.05)");
            glareGrad.addColorStop(0.6, "rgba(255, 255, 255, 0)");

            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = glareGrad;
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.9, 0, Math.PI * 2);
            ctx.fill();

            // Specular highlight (Crisp, keeps the glass feel)
            ctx.translate(x + radius * 0.5, y + radius * 0.5);
            ctx.rotate(-Math.PI / 4);
            ctx.beginPath();
            ctx.ellipse(0, 0, radius * 0.15, radius * 0.08, 0, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 255, 255, 0.5)"; // Slightly clearer
            // ctx.filter = "blur(2px)"; // Removed blur for performance
            ctx.fill();

            ctx.restore();
        }

        function drawTrueCircle() {
            vizCtx.clearRect(0, 0, vizWidth, vizHeight);

            // Animation
            zoomLevel += (targetZoom - zoomLevel) * 0.1;
            if ((autoRotating && !isDragging && !isModalOpen) || (isModalOpen)) {
                autoRotationAngle += 0.002;
                if (!isModalOpen) {
                    currentRotation.x = Math.sin(autoRotationAngle) * 0.3;
                    currentRotation.y = Math.cos(autoRotationAngle) * 0.3;
                } else {
                    currentRotation.y += 0.002; // Spin slowly when modal open
                }
            } else {
                currentRotation.x += (targetRotation.x - currentRotation.x) * 0.1;
                currentRotation.y += (targetRotation.y - currentRotation.y) * 0.1;
            }

            let scale = (Math.min(vizWidth, vizHeight) / 550) * zoomLevel;
            // Mobile adjust
            if (window.innerWidth < 500) scale *= 0.8;

            const cx = (vizWidth / 2) + vizOffset.x;
            const cy = (vizHeight / 2) + vizOffset.y;
            const rotX = currentRotation.y * 4.5;
            const rotY = currentRotation.x * 4.5;
            const perspective = 850 * scale;

            // Project Center first
            let cX = centerNode.baseX * scale, cY = centerNode.baseY * scale, cZ = centerNode.baseZ * scale;
            let cX1 = cX * Math.cos(rotY) - cZ * Math.sin(rotY);
            let cZ1 = cZ * Math.cos(rotY) + cX * Math.sin(rotY);
            let cY2 = cY * Math.cos(rotX) - cZ1 * Math.sin(rotX);
            let cZ2 = cZ1 * Math.cos(rotX) + cY * Math.sin(rotX);
            let cP = perspective / (perspective + cZ2);
            let centerProj = { x: cx + cX1 * cP, y: cy + cY2 * cP, scale: cP, z: cZ2 };

            // Project Nodes
            let projected = [];
            sphereNodes.forEach(node => {
                if (node.layerRank > settings.maxRank) return;
                // Timelapse Visibility Check
                if (isTimelapseActive && node.isTimelapsedHidden && node.group !== 'Center') return;

                let vis = isNodeVisible(node);
                let nX = node.baseX * scale, nY = node.baseY * scale, nZ = node.baseZ * scale;
                let x1 = nX * Math.cos(rotY) - nZ * Math.sin(rotY);
                let z1 = nZ * Math.cos(rotY) + nX * Math.sin(rotY);
                let y2 = nY * Math.cos(rotX) - z1 * Math.sin(rotX);
                let z2 = z1 * Math.cos(rotX) + nY * Math.sin(rotX);
                let p = perspective / (perspective + z2);
                projected.push({
                    x: cx + x1 * p, y: cy + y2 * p, z: z2, scale: p,
                    node: node, isVisible: vis, index: node.index
                });
            });

            // Generate Connections (with update flag support)
            if (stableConnections.length === 0 || connectionsNeedUpdate) {
                stableConnections = [];
                connectionData = {};
                for (let i = 0; i < sphereNodes.length; i++) {
                    for (let j = i + 1; j < sphereNodes.length; j++) {
                        let n1 = sphereNodes[i], n2 = sphereNodes[j];
                        let d = Math.sqrt((n1.baseX - n2.baseX) ** 2 + (n1.baseY - n2.baseY) ** 2 + (n1.baseZ - n2.baseZ) ** 2);
                        if (d < baseRadius * 2.5) {
                            let rank1 = n1.layerRank, rank2 = n2.layerRank;
                            let prob = 0.05 * settings.connectionDensity;
                            if (rank1 === 1 && rank2 === 1) prob = 0.8 * settings.connectionDensity;
                            else if (rank1 === rank2) prob = 0.15 * settings.connectionDensity;

                            if (Math.random() < prob) {
                                let key = `${i}-${j}`;
                                connectionData[key] = {
                                    name1: n1.name, name2: n2.name,
                                    connectionDate: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000 * 5),
                                    index1: i, index2: j, rank: Math.max(rank1, rank2)
                                };
                                stableConnections.push({ data: connectionData[key], index1: i, index2: j });
                            }
                        }
                    }
                }
                connectionsNeedUpdate = false;
                identifyOrphans();
            }

            // Draw Links
            if (settings.showCenterLinks) {
                projected.forEach(p => {
                    if (!p.isVisible) return;
                    vizCtx.beginPath();
                    vizCtx.moveTo(centerProj.x, centerProj.y);
                    vizCtx.lineTo(p.x, p.y);
                    vizCtx.strokeStyle = `rgba(0,0,0,${0.1 * p.scale})`;
                    vizCtx.lineWidth = 0.5;
                    vizCtx.stroke();
                });
            }

            if (settings.showConnections) {
                stableConnections.forEach(c => {
                    if (c.data.rank > settings.maxRank) return;

                    // Timelapse Connection Check
                    if (isTimelapseActive) {
                        let n1 = sphereNodes[c.index1];
                        let n2 = sphereNodes[c.index2];
                        // Only show if BOTH nodes are visible (meaning, revealed by timeline)
                        if ((n1.isTimelapsedHidden && n1.group !== 'Center') || (n2.isTimelapsedHidden && n2.group !== 'Center')) return;
                    }
                    let p1 = projected[c.index1], p2 = projected[c.index2];
                    if (!p1 || !p2 || !p1.isVisible || !p2.isVisible) return;

                    let connKey = `${c.index1}-${c.index2}`;
                    let isClicked = connKey === clickedConnectionKey;

                    vizCtx.beginPath();
                    vizCtx.moveTo(p1.x, p1.y);
                    vizCtx.lineTo(p2.x, p2.y);
                    vizCtx.strokeStyle = isClicked ? `rgba(0,0,0,0.6)` : `rgba(0,0,0,0.15)`;
                    vizCtx.lineWidth = (isClicked ? 3 : 1) * settings.linkThicknessMultiplier;
                    vizCtx.stroke();
                });
            }

            // Draw Nodes
            // Center - show photo when zoomed
            let cR = (5 * scale) * centerProj.scale * settings.nodeSizeMultiplier;
            const PHOTO_ZOOM_THRESHOLD = 2.5; // Show photos above this zoom level
            const showPhotos = zoomLevel >= PHOTO_ZOOM_THRESHOLD;

            if (showPhotos) {
                // Draw center with ELOI photo
                let centerImg = getLabelImage({ index: -1 });
                if (centerImg && centerImg.complete) {
                    let photoR = Math.max(cR * 1.5, 30);
                    drawLiquidBubble(vizCtx, centerProj.x, centerProj.y, photoR, centerImg);
                } else {
                    vizCtx.beginPath(); vizCtx.arc(centerProj.x, centerProj.y, cR * 1.3, 0, Math.PI * 2);
                    vizCtx.fillStyle = '#000'; vizCtx.fill();
                    vizCtx.strokeStyle = '#000'; vizCtx.lineWidth = 1; vizCtx.stroke();
                }
            } else {
                vizCtx.beginPath(); vizCtx.arc(centerProj.x, centerProj.y, cR, 0, Math.PI * 2);
                vizCtx.fillStyle = '#000'; vizCtx.fill();
            }

            // Others (sort by Z - draw back to front)
            // Others (sort by Z - draw back to front)
            projected.sort((a, b) => b.z - a.z).forEach(p => {
                if (!p.isVisible) return;
                let r = (2.5 * scale) * p.scale * settings.nodeSizeMultiplier;
                if (p.index === hoveredNodeIndex || p.index === clickedNodeIndex) r *= 1.5;

                if (showPhotos) {
                    // Photo mode - larger circular photos
                    let img = getLabelImage(p.node);

                    if (img && img.complete) {
                        let photoR = Math.max(r * 1.8, 20); // Minimum 20px radius
                        drawLiquidBubble(vizCtx, p.x, p.y, photoR, img);
                    } else {
                        // Fallback to colored circle while loading
                        vizCtx.beginPath(); vizCtx.arc(p.x, p.y, r, 0, Math.PI * 2);
                        vizCtx.fillStyle = `rgba(${p.node.color.r},${p.node.color.g},${p.node.color.b},${p.scale})`;
                        vizCtx.fill();
                    }
                } else {
                    // Normal mode - colored dots
                    vizCtx.beginPath(); vizCtx.arc(p.x, p.y, r, 0, Math.PI * 2);
                    vizCtx.fillStyle = `rgba(${p.node.color.r},${p.node.color.g},${p.node.color.b},${p.scale})`;
                    vizCtx.fill();
                }
            });

            // Draw Labels logic (Simplified for Mobile)
            // Always draw label for focused/clicked
            let labelTarget = null;
            if (isHoveringCenter || isCenterClicked || clickedNodeIndex === -1) labelTarget = { x: centerProj.x, y: centerProj.y, name: "ELOI", rank: 0, index: -1 };
            else if (clickedNodeIndex >= 0) {
                let found = projected.find(p => p.index === clickedNodeIndex);
                if (found) labelTarget = { x: found.x, y: found.y, name: found.node.name, rank: found.node.layerRank, index: found.index };
            }

            if (labelTarget) {
                drawEngineeringLabel(vizCtx, labelTarget.x, labelTarget.y, labelTarget.name, labelTarget.rank, labelTarget.index);
            }

            requestAnimationFrame(drawTrueCircle);
        }

        function drawEngineeringLabel(ctx, x, y, text, rank, index) {
            let labelDist = 60;
            let labelX = x + labelDist;
            let labelY = y - 40;

            // Line
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(labelX, labelY);
            ctx.strokeStyle = "rgba(0,0,0,0.6)"; ctx.stroke();

            // Box
            let padding = 8;
            let fontSize = 14;
            ctx.font = `600 ${fontSize}px -apple-system`;
            let txt = text + toSuperscript(rank);
            let w = ctx.measureText(txt).width + 20;

            ctx.fillStyle = "rgba(255,255,255,0.9)";
            ctx.fillRect(labelX, labelY - 15, w + 40, 30); // Extra width for image
            ctx.strokeStyle = "rgba(0,0,0,0.1)";
            ctx.strokeRect(labelX, labelY - 15, w + 40, 30);

            // Image
            let img = getLabelImage({ index: index, name: text });
            if (img) {
                ctx.drawImage(img, labelX + 2, labelY - 13, 26, 26);
                ctx.rect(labelX + 2, labelY - 13, 26, 26);
                ctx.stroke();
            }

            ctx.fillStyle = "#000";
            ctx.fillText(txt, labelX + 35, labelY + 5);
        }

        // ==========================================
        // 5. INTERACTION & UI
        // ==========================================

        // Touch Handlers
        vizCanvas.addEventListener('touchstart', e => {
            if (isSettingsOpen || isModalOpen) return;
            e.preventDefault();
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                lastTouchX = touchStartX; lastTouchY = touchStartY;
                isDragging = true; hasMoved = false;
                // Trigger hit detection on touch start instead of release
                performTouchHit(touchStartX, touchStartY);
                autoRotating = false;
            } else if (e.touches.length === 2) {
                let dx = e.touches[0].clientX - e.touches[1].clientX;
                let dy = e.touches[0].clientY - e.touches[1].clientY;
                initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                initialPinchMidpoint = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                initialZoom = targetZoom;
                gestureMode = null;
            }
        }, { passive: false });

        vizCanvas.addEventListener('touchmove', e => {
            if (isSettingsOpen || isModalOpen) return;
            e.preventDefault();
            if (e.touches.length === 1 && isDragging) {
                let dx = e.touches[0].clientX - lastTouchX;
                let dy = e.touches[0].clientY - lastTouchY;
                if (Math.abs(e.touches[0].clientX - touchStartX) > 5 || Math.abs(e.touches[0].clientY - touchStartY) > 5) hasMoved = true;

                targetRotation.x += dy * 0.005;
                targetRotation.y += dx * 0.005;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                autoRotating = false;
            } else if (e.touches.length === 2) {
                let centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                let centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                let dx = e.touches[0].clientX - e.touches[1].clientX;
                let dy = e.touches[0].clientY - e.touches[1].clientY;
                let currentDist = Math.sqrt(dx * dx + dy * dy);

                if (gestureMode === null) {
                    let moveDist = Math.sqrt((centerX - initialPinchMidpoint.x) ** 2 + (centerY - initialPinchMidpoint.y) ** 2);
                    let zoomDist = Math.abs(currentDist - initialPinchDistance);

                    if (moveDist > 20) gestureMode = 'pan';
                    else if (zoomDist > 30) gestureMode = 'zoom';
                }

                if (gestureMode === 'zoom') {
                    targetZoom = Math.max(0.1, Math.min(10.0, initialZoom * (currentDist / initialPinchDistance)));
                } else if (gestureMode === 'pan') {
                    if (lastPinchCenterX !== undefined) {
                        vizOffset.x += centerX - lastPinchCenterX;
                        vizOffset.y += centerY - lastPinchCenterY;
                    }
                }

                lastPinchCenterX = centerX;
                lastPinchCenterY = centerY;
                autoRotating = false;
            }
        }, { passive: false });

        vizCanvas.addEventListener('touchend', e => {
            isDragging = false;
            lastPinchCenterX = undefined; // Reset pan state
            lastPinchCenterY = undefined;
        });

        // Mouse Support (Desktop as Mobile)
        vizCanvas.addEventListener('mousedown', e => {
            if (isSettingsOpen || isModalOpen) return;
            // NopreventDefault to allow focus, etc if needed, but here mostly graphic
            // e.preventDefault(); 

            touchStartX = e.clientX;
            touchStartY = e.clientY;
            lastTouchX = touchStartX;
            lastTouchY = touchStartY;
            isDragging = true;
            hasMoved = false;

            // Trigger hit detection on mouse down instead of release
            performTouchHit(e.clientX, e.clientY);
            autoRotating = false;
        });

        window.addEventListener('mousemove', e => {
            if (isSettingsOpen || isModalOpen) return;

            if (isDragging) {
                e.preventDefault();
                let dx = e.clientX - lastTouchX;
                let dy = e.clientY - lastTouchY;

                if (Math.abs(e.clientX - touchStartX) > 5 || Math.abs(e.clientY - touchStartY) > 5) hasMoved = true;

                targetRotation.x += dy * 0.005;
                targetRotation.y += dx * 0.005;

                lastTouchX = e.clientX;
                lastTouchY = e.clientY;
                autoRotating = false;
            }
        });

        window.addEventListener('mouseup', e => {
            isDragging = false;
        });

        function performTouchHit(x, y) {
            const rect = vizCanvas.getBoundingClientRect();
            let tx = x - rect.left;
            let ty = y - rect.top;

            let scale = (Math.min(vizWidth, vizHeight) / 550) * zoomLevel;
            if (window.innerWidth < 500) scale *= 0.8;

            const cx = (vizWidth / 2) + vizOffset.x;
            const cy = (vizHeight / 2) + vizOffset.y;
            const rotX = currentRotation.y * 4.5;
            const rotY = currentRotation.x * 4.5;
            const perspective = 850 * scale;

            // Project center (ELOI)
            let cX = centerNode.baseX * scale, cY = centerNode.baseY * scale, cZ = centerNode.baseZ * scale;
            let cX1 = cX * Math.cos(rotY) - cZ * Math.sin(rotY);
            let cZ1 = cZ * Math.cos(rotY) + cX * Math.sin(rotY);
            let cY2 = cY * Math.cos(rotX) - cZ1 * Math.sin(rotX);
            let cZ2 = cZ1 * Math.cos(rotX) + cY * Math.sin(rotX);
            let cP = perspective / (perspective + cZ2);
            let centerProjX = cx + cX1 * cP;
            let centerProjY = cy + cY2 * cP;

            // 1. Check Center (ELOI) - ENLARGED hit radius synced with boosted visual size
            let cR = (15 * scale) * cP * settings.nodeSizeMultiplier;
            let centerHitRadius = Math.max(30, cR * 1.5);
            if (Math.sqrt((tx - centerProjX) ** 2 + (ty - centerProjY) ** 2) < centerHitRadius) {
                openModal({ name: ELOI_DATA.name, age: ELOI_DATA.age, layerRank: 0, group: "Center", index: -1, isEloi: true });
                return;
            }

            // Helper: project a node
            function projectNode(node) {
                let nX = node.baseX * scale, nY = node.baseY * scale, nZ = node.baseZ * scale;
                let x1 = nX * Math.cos(rotY) - nZ * Math.sin(rotY);
                let z1 = nZ * Math.cos(rotY) + nX * Math.sin(rotY);
                let y2 = nY * Math.cos(rotX) - z1 * Math.sin(rotX);
                let z2 = z1 * Math.cos(rotX) + nY * Math.sin(rotX);
                let p = perspective / (perspective + z2);
                return { x: cx + x1 * p, y: cy + y2 * p, z: z2, scale: p };
            }

            // Apple HIG: 44 points is ideal, but for dense graph we use smaller min to avoid 
            // overlapping invisible clicks. Radius 12px = 24px diameter.
            const MIN_TOUCH_RADIUS = 12;

            // Build candidates array with projections
            let candidates = [];
            sphereNodes.forEach(node => {
                if (!isNodeVisible(node)) return;
                let proj = projectNode(node);
                let visualRadius = (2.5 * scale) * proj.scale * settings.nodeSizeMultiplier;

                // Synchronize hit zone with photo rendering if zoomed in
                let hitRadius;
                if (zoomLevel >= 2.5) {
                    // Match drawTrueCircle's photoR: Math.max(r * 1.8, 20)
                    hitRadius = Math.max(visualRadius * 1.8, 20);
                } else {
                    // Dot mode radius
                    hitRadius = Math.max(MIN_TOUCH_RADIUS, visualRadius * 2);
                }

                let d = Math.sqrt((tx - proj.x) ** 2 + (ty - proj.y) ** 2);
                if (d < hitRadius) {
                    candidates.push({ node, dist: d, z: proj.z, hitRadius });
                }
            });

            // Sort by: 1) distance (closest first), 2) Z-depth (foreground first = smaller z)
            candidates.sort((a, b) => {
                // Weight distance more heavily, but use Z as tiebreaker
                let distDiff = a.dist - b.dist;
                if (Math.abs(distDiff) < 10) {
                    // Within 10px, prefer foreground node
                    return a.z - b.z;
                }
                return distDiff;
            });

            if (candidates.length > 0) {
                // Critical: Ensure the closest candidate is actually within its HIT RADIUS
                // The candidate list is already filtered by d < hitRadius, so this is safe.
                // But let's double check there is no logic error. 
                // Previous logic pushed to candidates ONLY if d < hitRadius. 
                // So if we are here, we have a valid hit.

                let clicked = candidates[0].node;
                clickedNodeIndex = clicked.index;
                clickedConnectionKey = null;
                openModal(clicked);
                return;
            }

            // 3. Connection Hit Detection
            // "Guard Zone" principle: if touch is near a node (even if not a hit), ignore connections
            // This prioritizes nodes and prevents accidental connection clicks
            const NODE_GUARD_RADIUS = 50; // 50px guard zone around nodes
            let inGuardZone = false;
            sphereNodes.forEach(node => {
                if (inGuardZone || !isNodeVisible(node)) return;
                let proj = projectNode(node);
                // Simple distance check to projected center
                if (Math.sqrt((tx - proj.x) ** 2 + (ty - proj.y) ** 2) < NODE_GUARD_RADIUS) {
                    inGuardZone = true;
                }
            });

            if (inGuardZone) {
                // If we are close to a node but missed it, do NOT click a connection.
                // Just clear selection.
                if (isModalOpen) closeModal();
                clickedNodeIndex = -2;
                clickedConnectionKey = null;
                return;
            }

            if (settings.showConnections) {
                // Reduced threshold for connections - harder to hit, cleaner UI
                let connHitThreshold = Math.max(10, 5 * scale);
                for (let conn of stableConnections) {
                    if (conn.data.rank > settings.maxRank) continue;
                    let n1 = sphereNodes[conn.index1], n2 = sphereNodes[conn.index2];
                    if (!n1 || !n2 || !isNodeVisible(n1) || !isNodeVisible(n2) || n1.layerRank > settings.maxRank || n2.layerRank > settings.maxRank) continue;
                    let p1 = projectNode(n1), p2 = projectNode(n2);
                    let dist = distancePointToSegment(tx, ty, p1.x, p1.y, p2.x, p2.y);
                    if (dist <= connHitThreshold) {
                        clickedConnectionKey = `${conn.index1}-${conn.index2}`;
                        clickedNodeIndex = -2;
                        openConnectionModal(conn.data);
                        return;
                    }
                }
            }

            // 4. Click in empty space
            if (isModalOpen) closeModal();
            clickedNodeIndex = -2;
            clickedConnectionKey = null;
        }

        // Connection Modal
        function openConnectionModal(connData) {
            isModalOpen = true;
            let clean1 = nameToFilename(connData.name1), clean2 = nameToFilename(connData.name2);
            let dateStr = connData.connectionDate ? connData.connectionDate.toLocaleDateString('fr-FR') : 'N/A';
            modalContent.innerHTML = `
                <div class="connection-photos-row">
                    <div class="connection-photo-container" onclick="openModalFromConnection('${connData.name1}', ${connData.index1})">
                        <img src="/truecircle/${clean1}.jpg" class="connection-photo" onerror="this.src='https://via.placeholder.com/80'">
                    </div>
                    <div class="connection-photo-container" onclick="openModalFromConnection('${connData.name2}', ${connData.index2})">
                        <img src="/truecircle/${clean2}.jpg" class="connection-photo" onerror="this.src='https://via.placeholder.com/80'">
                    </div>
                </div>
                <div class="modal-name">${connData.name1} & ${connData.name2}</div>
                <div class="modal-info-row">
                    <span class="modal-info-label">Connectés depuis</span><span class="modal-info-value">${dateStr}</span>
                </div>
                <a href="https://wa.me/?text=${encodeURIComponent('Créer un groupe avec ' + connData.name1 + ' et ' + connData.name2)}" class="action-button" target="_blank">Créer groupe WhatsApp →</a>
            `;
            modalSheet.classList.add('visible');
            modalOverlay.classList.add('visible');
        }

        window.openModalFromConnection = function (name, index) {
            let node = sphereNodes.find(n => n.index === index);
            if (node) { closeModal(); setTimeout(() => openModal(node), 100); }
        };

        // ==========================================
        // 6. UI LOGIC (Fab, Sheet, Search)
        // ==========================================
        const fab = document.getElementById('settings-fab');
        const bottomSheet = document.getElementById('bottom-sheet');
        const sheetOverlay = document.getElementById('bottom-sheet-overlay');
        const modalSheet = document.getElementById('modal-sheet');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');

        fab.addEventListener('click', () => {
            isSettingsOpen = true;
            bottomSheet.classList.add('visible');
            sheetOverlay.classList.add('visible');
        });

        sheetOverlay.addEventListener('click', () => {
            isSettingsOpen = false;
            bottomSheet.classList.remove('visible');
            sheetOverlay.classList.remove('visible');
        });

        // Search
        const searchInput = document.getElementById('search-input');
        const searchRes = document.getElementById('search-results');
        const searchClear = document.getElementById('search-clear');

        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                searchRes.style.display = 'none';
                enterSearchMode(searchInput.value);
                searchInput.blur();
            }
        });

        searchClear.addEventListener('click', () => {
            exitSearchMode();
        });

        searchInput.addEventListener('input', e => {
            let q = e.target.value.toLowerCase().trim();
            settings.searchQuery = q;
            if (q.length < 2) { searchRes.style.display = 'none'; return; }
            // Strict prefix search using masterNodes
            let res = masterNodes.filter(n => n.name.toLowerCase().startsWith(q)).slice(0, 10);
            searchRes.innerHTML = res.map(n =>
                `<div class="search-result-item" style="padding: 12px 16px; border-bottom: 1px solid rgba(0,0,0,0.05); display: flex; align-items: center;">
                    <!-- Sphere Action -->
                    <div onclick="selectSearchGraph('${n.name}')" style="width: 32px; height: 32px; border-radius: 50%; background: #f0f0f0; display: flex; align-items: center; justify-content: center; margin-right: 12px; cursor: pointer; flex-shrink: 0;">
                         <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="#333" stroke-width="2">
                             <circle cx="12" cy="12" r="10"/>
                             <path d="M2.5 12h19M12 2.5v19M4 18l16-12M4 6l16 12"/>
                         </svg>
                    </div>

                    <!-- Card Action (Rest of row) -->
                    <div onclick="selectSearchNode(${n.index})" style="flex:1; display: flex; align-items: center; cursor: pointer;">
                        <img src="/truecircle/${nameToFilename(n.name)}.jpg" onerror="this.src='https://via.placeholder.com/40'" style="width: 36px; height: 36px; border-radius: 50%; margin-right: 12px; object-fit: cover;">
                        <div style="flex:1">
                            <div class="search-result-name" style="font-weight:600; font-size:16px;">${n.name}</div>
                            <div class="search-result-meta" style="font-size:13px; color:#888;">${n.age} ans • Rang ${n.layerRank}</div>
                        </div>
                    </div>
                 </div>`
            ).join('');
            searchRes.style.display = 'block';
        });

        window.selectSearchNode = function (index) {
            let node = masterNodes.find(n => n.index === index);
            if (node) {
                // Just open the card, do not enter search sphere mode
                searchRes.style.display = 'none';
                searchInput.value = ''; // specific selection usually clears query or keeps it? 
                // User said: "Cliquer en dehors... emmène sur la carte de l'individu"
                // It implies we leave search mode or stay in global mode but focus on this node.
                // Let's assume Global Mode + Auto Rank + Modal.

                // Auto-expand rank if needed (copy logic from old selectSearchNode)
                if (node.layerRank > settings.maxRank) {
                    settings.maxRank = node.layerRank;
                    connectionsNeedUpdate = true;
                    // Update UI
                    const slider = document.querySelector('#rank-range');
                    if (slider) slider.value = settings.maxRank;
                    const label = document.querySelector('#rank-value');
                    if (label) label.textContent = settings.maxRank;
                }

                clickedNodeIndex = node.index;
                openModal(node);
            }
        };

        window.selectSearchGraph = function (name) {
            searchRes.style.display = 'none';
            searchInput.value = name;
            enterSearchMode(name);
        };



        // Modal
        function openModal(node) {
            isModalOpen = true;
            let clean = nameToFilename(node.name);
            let commonConnections = getCommonConnections(node.index);

            let commonHTML = '';
            if (commonConnections.length > 0) {
                commonHTML = `
                    <div class="common-connections-section">
                        <div class="common-connections-label">Connaissances communes (${commonConnections.length})</div>
                        <div class="common-connections-list">
                        <div class="common-connections-list">
                            ${commonConnections.map(cn => `
                                <div class="common-connection-item" onclick="openModalFromConnection('${cn.name}', ${cn.index})">
                                    <img src="/truecircle/${nameToFilename(cn.name)}.jpg" class="common-connection-photo" onerror="this.src='https://via.placeholder.com/40'">
                                    <span class="common-connection-name">${cn.name}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            modalContent.innerHTML = `
                <img src="/truecircle/${clean}.jpg" class="modal-photo" onerror="this.src='https://via.placeholder.com/100'">
                <div class="modal-name">${node.name}</div>
                <div class="modal-info-row">
                    <span class="modal-info-label">Âge</span><span class="modal-info-value">${node.age} ans</span>
                </div>
                <div class="modal-info-row">
                    <span class="modal-info-label">Rang</span><span class="modal-info-value">${node.layerRank}${toSuperscript(node.layerRank)}</span>
                </div>
                <div class="modal-info-row">
                    <span class="modal-info-label">Groupe</span><span class="modal-info-value">${node.group}</span>
                </div>
                ${(function () {
                    if (!node.connectionDate) return '';
                    let d = node.connectionDate;
                    let day = String(d.getDate()).padStart(2, '0');
                    let month = String(d.getMonth() + 1).padStart(2, '0');
                    let year = d.getFullYear();
                    return `<div class="modal-info-row"><span class="modal-info-label">Connecté(e) le</span><span class="modal-info-value">${day}-${month}-${year}</span></div>`;
                })()}
                ${commonHTML}
                <a href="#" class="action-button" onclick="return handleViewFullProfile(event, '${node.name}', ${node.layerRank})">Voir profil complet</a>
            `;
            modalSheet.classList.add('visible');
            modalOverlay.classList.add('visible');
        }

        function closeModal() {
            isModalOpen = false;
            clickedNodeIndex = -2;
            modalSheet.classList.remove('visible');
            modalOverlay.classList.remove('visible');
            autoRotating = true; // Resume rotation
        }

        // STATS App Integration: Navigate to full profile in STATS App
        window.handleViewFullProfile = function (event, name, rank) {
            event.preventDefault();

            // Only Rank 1 (Inner Circle) friends can view full profile in STATS
            if (rank !== 1) {
                alert('Le profil complet est disponible uniquement pour le Cercle Intime (Rang 1).\n\nCette personne n\'est pas encore assez proche pour avoir un profil STATS.');
                return false;
            }

            // Navigate to STATS App with contact preselected
            // The URL structure matches STATS App's expected format
            window.location.href = '/?view=view-social&contactName=' + encodeURIComponent(name);
            return false;
        };

        modalOverlay.addEventListener('click', closeModal);

        // Bind Settings Control
        document.getElementById('group-family').onchange = e => settings.groupFamily = e.target.checked;
        document.getElementById('group-work').onchange = e => settings.groupWork = e.target.checked;
        document.getElementById('group-friends').onchange = e => settings.groupFriends = e.target.checked;
        document.getElementById('show-names').onchange = e => settings.showNames = e.target.checked;
        document.getElementById('show-connections').onchange = e => settings.showConnections = e.target.checked;
        document.getElementById('show-center-links').onchange = e => settings.showCenterLinks = e.target.checked;
        document.getElementById('show-connection-labels').onchange = e => settings.showConnectionLabels = e.target.checked;
        document.getElementById('filter-by-age').onchange = e => settings.filterByAge = e.target.checked;
        document.getElementById('filter-oldest').onchange = e => {
            settings.filterOldest = e.target.checked;
            if (e.target.checked) { settings.filterMostRecent = false; document.getElementById('filter-most-recent').checked = false; }
        };
        document.getElementById('filter-most-recent').onchange = e => {
            settings.filterMostRecent = e.target.checked;
            if (e.target.checked) { settings.filterOldest = false; document.getElementById('filter-oldest').checked = false; }
        };
        document.getElementById('filter-orphans').onchange = e => settings.filterOrphans = e.target.checked;

        document.getElementById('rank-range').oninput = e => {
            settings.maxRank = parseInt(e.target.value);
            document.getElementById('rank-value').textContent = e.target.value;
            initTrueCircle();
            connectionsNeedUpdate = true;
        };
        document.getElementById('density-range').oninput = e => {
            settings.connectionDensity = parseInt(e.target.value) / 100;
            document.getElementById('density-value').textContent = e.target.value + '%';
            stableConnections = []; // Clear to force regeneration
            connectionsNeedUpdate = true;
        };
        document.getElementById('node-size-range').oninput = e => {
            settings.nodeSizeMultiplier = parseInt(e.target.value) / 100;
            document.getElementById('node-size-value').textContent = e.target.value + "%";
        };
        document.getElementById('link-width-range').oninput = e => {
            settings.linkThicknessMultiplier = parseInt(e.target.value) / 100;
            document.getElementById('link-width-value').textContent = e.target.value + "%";
        };


        // ==========================================
        // TIMELAPSE LOGIC
        // ==========================================
        let isTimelapseActive = false;
        let originalMaxRank = 5;

        // Make it global
        window.toggleTimelapse = function () {
            if (isTimelapseActive) {
                stopTimelapse();
            } else {
                startTimelapse();
            }
        };

        function startTimelapse() {
            if (isTimelapseActive) return;
            isTimelapseActive = true;

            // 1. Save state & Auto-expand Rank
            originalMaxRank = settings.maxRank;
            if (settings.maxRank < 5) {
                settings.maxRank = 5;
                // Update UI sliders too
                const slider = document.querySelector('#rank-range');
                if (slider) slider.value = 5;
                const label = document.querySelector('#rank-value');
                if (label) label.textContent = '5';

                // Force regeneration to ensure all nodes are present in sphereNodes
                initTrueCircle(); // Re-runs generation with new maxRank logic if needed, or just re-filters
            }

            // 2. Clear view (except center)
            document.getElementById('timelapse-fab').style.opacity = '0.5';
            const dateDisplay = document.getElementById('timelapse-date-display');
            dateDisplay.style.opacity = '1';

            // Hide all connections initially
            stableConnections.forEach(c => c.isTimelapsed = false);
            // Hide all nodes initially (except center)
            sphereNodes.forEach(n => {
                if (n.group === 'Center') return;
                n.isTimelapsedHidden = true;
            });
            connectionsNeedUpdate = true;

            // 3. Animation Loop
            let currentIndex = 0;
            // Filter nodes that define the history (exclude center)
            const timelineNodes = sphereNodes.filter(n => n.group !== 'Center');

            // Add global click listener to stop
            setTimeout(() => {
                window.addEventListener('click', stopTimelapseHandler);
                window.addEventListener('touchstart', stopTimelapseHandler);
            }, 100);

            // Exponential Speed Config
            const totalNodes = timelineNodes.length;
            const startDelay = 150;
            const endDelay = 0.05;    // Targeting ultra-fast batching at the end
            // Decay setup
            const decayFactor = Math.pow(endDelay / startDelay, 1 / totalNodes);

            function nextFrame() {
                if (!isTimelapseActive) return;

                if (currentIndex >= timelineNodes.length) {
                    stopTimelapse();
                    return;
                }

                // Calculate next theoretical delay
                let currentDelay = startDelay * Math.pow(decayFactor, currentIndex);

                // Dynamic Batching
                // If delay is small, process multiple nodes to maintain ~16ms (60fps) or faster frame budget
                // We want to clear the queue rapidly if delay is effectively 0
                let batchBudgetMs = 5; // Allow 5ms of processing time per frame roughly
                let nodesToProcess = 1;

                if (currentDelay < 8) {
                    // roughly how many fit in 5ms? 
                    // If delay is 0.05, we want 100 per chunk?
                    // Let's be aggressive for the 'crowd' (2022+)
                    nodesToProcess = Math.ceil(8 / Math.max(0.01, currentDelay));
                }

                for (let b = 0; b < nodesToProcess; b++) {
                    if (currentIndex >= timelineNodes.length) break;
                    let node = timelineNodes[currentIndex];
                    node.isTimelapsedHidden = false;
                    currentIndex++;

                    // Update Date only for the last one in batch
                    if (b === nodesToProcess - 1 && node.connectionDate) {
                        let d = node.connectionDate;
                        let monthNames = ["Jan", "Fév", "Mar", "Avr", "Mai", "Juin", "Juil", "Août", "Sep", "Oct", "Nov", "Déc"];
                        dateDisplay.textContent = `${monthNames[d.getMonth()]} ${d.getFullYear()}`;
                    }
                }

                // REMOVED: connectionsNeedUpdate = true; -> This was causing massive lag by regenerating connections
                // The visibility check in drawTrueCircle is sufficient.

                // Clamp timeout to minimum 4ms (browser limit) but logic allows "skipping" time by batching
                setTimeout(nextFrame, Math.max(4, currentDelay * nodesToProcess));
                // Actually, if we batch 100 items that supposedly take 0.05ms each = 5ms total block.
                // We can wait 5ms or just requestAnimationFrame. 
                // Let's use simple timeout for now.
            }

            nextFrame();
        }

        function stopTimelapse() {
            isTimelapseActive = false;
            document.getElementById('timelapse-fab').style.opacity = '1';
            document.getElementById('timelapse-date-display').style.opacity = '0';

            // Restore visibility
            sphereNodes.forEach(n => delete n.isTimelapsedHidden);

            // Persist Rank 5 (Keep the full view)
            if (settings.maxRank !== 5) {
                settings.maxRank = 5;
                // Update UI to reflect Rank 5
                const slider = document.querySelector('#rank-range');
                if (slider) slider.value = 5;
                const label = document.querySelector('#rank-value');
                if (label) label.textContent = '5';

                // We might need to ensure nodes are visible if they weren't before
                // But startTimelapse already set it to 5, so we should be good.
                // Just in case startTimelapse didn't finish or whatever:
                initTrueCircle();
            }

            // Remove listeners
            window.removeEventListener('click', stopTimelapseHandler);
            window.removeEventListener('touchstart', stopTimelapseHandler);

            connectionsNeedUpdate = true;
        }

        function stopTimelapseHandler(e) {
            // Ignore click on the fab itself if it triggered start
            if (e.target.closest('#timelapse-fab')) return;
            stopTimelapse();
        }

        // Sheet Drag Logic
        const sheetHeader = document.querySelector('.sheet-header-area');
        let sheetStartY = 0;
        let sheetCurrentY = 0;
        let sheetIsDragging = false;
        let sheetStartHeight = 0;

        sheetHeader.addEventListener('touchstart', dragStart, { passive: false });
        sheetHeader.addEventListener('touchmove', dragMove, { passive: false });
        sheetHeader.addEventListener('touchend', dragEnd);
        // Mouse for desktop
        sheetHeader.addEventListener('mousedown', dragStart);
        window.addEventListener('mousemove', dragMove);
        window.addEventListener('mouseup', dragEnd);

        function dragStart(e) {
            if (!isSettingsOpen) return;
            sheetIsDragging = true;
            sheetStartY = e.touches ? e.touches[0].clientY : e.clientY;
            bottomSheet.classList.add('dragging');
            // Allow event to propagate if needed, but grabber is mostly for drag
        }

        function dragMove(e) {
            if (!sheetIsDragging) return;
            e.preventDefault(); // Prevent scroll while dragging sheet
            let y = e.touches ? e.touches[0].clientY : e.clientY;
            let dy = y - sheetStartY;
            if (dy < 0) dy = dy * 0.3; // Resistance when pulling up beyond top

            bottomSheet.style.transform = `translateY(${Math.max(0, dy)}px)`;
            sheetCurrentY = dy;
        }

        function dragEnd(e) {
            if (!sheetIsDragging) return;
            sheetIsDragging = false;
            bottomSheet.classList.remove('dragging');
            bottomSheet.style.transform = ''; // Clear inline style to let class take over

            // Threshold to close
            if (sheetCurrentY > 100) {
                // Close
                isSettingsOpen = false;
                bottomSheet.classList.remove('visible');
                sheetOverlay.classList.remove('visible');
            } else {
                // Snap back to open
                bottomSheet.classList.add('visible'); // Ensure class is there
            }
            sheetCurrentY = 0;
        }

        // ==========================================
        // SEARCH SPHERE LOGIC
        // ==========================================
        function enterSearchMode(query) {
            query = query.trim();
            if (!query) return;

            if (!isSearchMode) {
                previousRank = settings.maxRank;
            }
            isSearchMode = true;
            settings.searchQuery = query;

            // 1. Filter Master Nodes (Strict Prefix)
            const matches = masterNodes.filter(n => n.name.toLowerCase().startsWith(query.toLowerCase()));

            if (matches.length === 0) {
                alert("Aucun résultat trouvé pour " + query);
                // Do not exit mode if just typing, but here we validated.
                return;
            }

            // 2. Reform Sphere with Matches Only
            const newSphereNodes = [];
            const count = matches.length;
            const searchSphereRadius = baseRadius * 1.5;

            for (let i = 0; i < count; i++) {
                let phi = Math.acos(-1 + (2 * i) / count);
                let theta = Math.sqrt(count * Math.PI) * phi;

                let originalNode = matches[i];
                let newNode = {
                    ...originalNode,
                    baseX: searchSphereRadius * Math.cos(theta) * Math.sin(phi),
                    baseY: searchSphereRadius * Math.sin(theta) * Math.sin(phi),
                    baseZ: searchSphereRadius * Math.cos(phi),
                    isSearchNode: true
                };
                newSphereNodes.push(newNode);
            }

            sphereNodes = newSphereNodes;

            // 3. Update UI & Camera
            vizOffset = { x: 0, y: 0 }; // Reset pan
            targetZoom = 1.0;
            // Force maxRank to 5 so all search results are visible
            settings.maxRank = 5;
            const slider = document.querySelector('#rank-range');
            if (slider) slider.value = 5;
            const label = document.querySelector('#rank-value');
            if (label) label.textContent = '5'; // Display just 5

            // Clear connections for search view to avoid clutter
            stableConnections = [];

            searchClear.style.display = 'block';
            searchRes.style.display = 'none';
        }

        function exitSearchMode() {
            isSearchMode = false;
            settings.searchQuery = '';
            searchInput.value = '';

            settings.maxRank = previousRank;
            const slider = document.querySelector('#rank-range');
            if (slider) slider.value = previousRank;
            const label = document.querySelector('#rank-value');
            if (label) label.textContent = previousRank;

            // Restore Global Sphere
            sphereNodes = [...masterNodes];

            // Restore Connections 
            connectionsNeedUpdate = true;

            // Reset Camera
            vizOffset = { x: 0, y: 0 };

            searchClear.style.display = 'none';
            searchRes.style.display = 'none';
        }

        // Init
        initTrueCircle();
        drawTrueCircle();

    </script>
</body>

</html>