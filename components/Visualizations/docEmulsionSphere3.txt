Ingénierie Avancée des Composants Circulaires Animés en React et TypeScript : De la Théorie Vectorielle à l'Implémentation Haute Performance
1. Introduction à la Micro-Interaction et à l'Excellence Visuelle
Dans le paysage contemporain du développement d'interfaces utilisateur, la frontière entre une application fonctionnelle et une expérience numérique immersive réside souvent dans la qualité de ses micro-interactions. La demande pour "un cercle animé comme sur la vidéo" ne constitue pas une simple requête esthétique ; elle traduit une exigence de fluidité, de réactivité physique et de sophistication graphique qui définit les standards modernes du web. Que ce soit pour visualiser le téléchargement d'un fichier lourd, indiquer le statut de chargement d'une application de streaming ou afficher une métrique de santé dans un tableau de bord analytique, le cercle animé est devenu l'archétype de l'élégance fonctionnelle.
Ce rapport technique, destiné aux architectes frontend et aux ingénieurs graphiques, explore de manière exhaustive la conception, l'implémentation, l'optimisation et la distribution de composants circulaires animés en utilisant React et TypeScript. Nous dépasserons les tutoriels superficiels pour plonger dans les mécanismes de rendu des navigateurs, les mathématiques vectorielles, la physique des ressorts (spring physics) et les stratégies d'accessibilité avancées. L'objectif est de fournir une compréhension atomique de chaque pixel rendu à l'écran.
1.1 L'Évolution des Paradigmes d'Animation Web
Pour comprendre comment réaliser une animation de haute fidélité aujourd'hui, il est essentiel de contextualiser les contraintes technologiques historiques. Au début du web, les indicateurs de chargement étaient dominés par le format GIF. Bien que simple à implémenter, le GIF souffrait de limitations inhérentes : une palette de couleurs restreinte à 256 nuances, une absence de canal alpha partiel (transparence binaire uniquement) et une impossibilité totale de contrôle programmatique. On ne pouvait ni accélérer, ni ralentir, ni changer la couleur d'un GIF en cours d'exécution sans recharger une nouvelle ressource.
L'avènement de Flash a temporairement offert une liberté totale, mais au prix de performances CPU catastrophiques et d'une fermeture propriétaire. Ce n'est qu'avec la maturation du DOM (Document Object Model) et l'intégration native du SVG (Scalable Vector Graphics) que nous avons atteint l'ère actuelle. Aujourd'hui, un cercle animé n'est pas une image ; c'est une équation mathématique rendue en temps réel par le moteur graphique du navigateur, pilotée par JavaScript, et stylisée par CSS.
Cependant, cette puissance a un coût : la complexité. Réaliser une animation fluide à 60 ou 120 images par seconde (FPS) sur un appareil mobile tout en exécutant une logique métier lourde en React nécessite une maîtrise parfaite du cycle de rendu (Render Cycle) et de la réconciliation.
1.2 Déconstruction de la Demande : "Comme sur la Vidéo"
L'expression "comme sur la vidéo" implique généralement un ensemble de caractéristiques visuelles qui distinguent une animation professionnelle d'une implémentation amateur :
1. Anti-aliasing parfait : Les courbes doivent être lisses, sans effet d'escalier, quelle que soit la densité de pixels de l'écran (DPI).
2. Physique naturelle : Les accélérations et décélérations ne doivent pas être linéaires. L'œil humain perçoit la linéarité comme artificielle. Les mouvements doivent suivre des courbes de Bézier (Ease-in-out) ou, mieux encore, des simulations de ressorts (Springs) qui réagissent à l'inertie.
3. Continuité d'état : Si le chargement passe de 20% à 50% instantanément, l'interface doit interpoler ces valeurs pour montrer le voyage entre les deux états, et non un saut quantique.
4. Richesse chromatique : L'utilisation de dégradés (gradients), d'ombres portées et de lueurs (glows) pour donner de la profondeur.
Nous aborderons ces exigences à travers le prisme de TypeScript, garantissant que notre code n'est pas seulement beau, mais aussi robuste, typé et maintenable à grande échelle.
________________
2. Fondements Mathématiques et Vectoriels du Rendu SVG
Avant d'écrire la première ligne de code .tsx, il est impératif de maîtriser le substrat sur lequel nous allons peindre : le SVG. Contrairement aux éléments HTML standards (div, span) qui suivent un modèle de boîte (box model) rectangulaire, le SVG habite un univers de coordonnées cartésiennes vectorielles.
2.1 La Géométrie du Cercle dans le DOM
Un cercle en SVG est défini par trois attributs principaux : cx (centre x), cy (centre y) et r (rayon). Cependant, pour animer le tracé de ce cercle, nous ne pouvons pas simplement changer ces coordonnées. Nous devons manipuler la bordure elle-même (stroke).
La propriété magique qui rend l'animation possible est le couple stroke-dasharray et stroke-dashoffset. Pour comprendre leur interaction, imaginons que la bordure du cercle n'est pas une ligne continue, mais une ligne en pointillés.
* stroke-dasharray définit la longueur des traits et des espaces. Si nous définissons un tiret dont la longueur est exactement égale au périmètre du cercle, le "tiret" fera tout le tour et rejoindra son début, créant l'illusion d'un cercle plein.
* stroke-dashoffset définit le décalage de départ de ce tiret. En modifiant ce décalage, nous pouvons "pousser" le tiret le long du chemin du cercle.


  



2.2 Le Calcul de la Circonférence ($C$)
La manipulation de ces attributs nécessite de connaître la longueur exacte du tracé. Pour un cercle, la formule est élémentaire mais cruciale :


$$C = 2 \times \pi \times r$$
Dans un contexte React, cette valeur $C$ devient notre constante de référence (100% de progression).
Si nous voulons afficher une progression de $P$ pourcent, le stroke-dashoffset ($O$) sera calculé comme suit :


$$O = C - (P / 100) \times C$$
Lorsque $P = 0$, $O = C$. Le trait est décalé de toute la longueur du cercle, rendant le cercle invisible (ou affichant l'espace vide).
Lorsque $P = 100$, $O = 0$. Le décalage est nul, le trait couvre tout le cercle.
2.3 L'Importance du viewBox et de la Normalisation
Un piège courant pour les développeurs juniors est de coder en dur des dimensions en pixels à l'intérieur du SVG. Cela rend le composant rigide et difficilement responsive. L'approche experte consiste à définir un système de coordonnées normalisé.
En utilisant un viewBox="0 0 100 100", nous créons un espace de travail virtuel de 100 unités par 100 unités. Peu importe que le SVG soit affiché sur un écran de 20px de large ou sur un mur vidéo de 4 mètres, nos calculs internes restent basés sur 100.
* Centre (cx, cy) : 50, 50
* Rayon (r) : Typiquement 40 ou 45 (pour laisser de la place à l'épaisseur du trait sans qu'il ne soit coupé par les bords du viewBox).
Cette abstraction mathématique permet de découpler la logique de rendu (le SVG) de la logique de mise en page (le CSS du conteneur parent).
________________
3. Architecture Logicielle : Typage et Modularité en React
L'utilisation de TypeScript .tsx nous impose une rigueur bénéfique. Nous ne créons pas simplement une fonction qui retourne du JSX ; nous définissons un contrat d'interface clair. Cela garantit que tout développeur utilisant ce composant saura exactement quelles propriétés sont requises et lesquelles sont optionnelles.
3.1 Définition de l'Interface des Props (AnimatedCircleProps)
Une interface robuste doit prévoir la personnalisation tout en offrant des valeurs par défaut sensées. Voici l'analyse détaillée des propriétés nécessaires pour un composant de niveau industriel.
Propriété
	Type
	Description Technique
	progress
	number
	La valeur actuelle de 0 à 100. Doit être clampée (limitée) pour éviter les erreurs de rendu si >100 ou <0.
	size
	number
	La dimension extérieure du composant en pixels. Utile pour calculer le style inline du conteneur.
	strokeWidth
	number
	L'épaisseur du trait. Attention : en SVG, le trait est centré sur le chemin. Un rayon de 45 avec un trait de 10 s'étendra de 40 à 50.
	color
	string
	La couleur de remplissage. Peut être un hexadécimal, un rgba, ou une référence à un ID de gradient SVG (url(#grad)).
	trackColor
	string
	La couleur du "rail" de fond, souvent un gris clair pour indiquer la trajectoire complète.
	loading
	boolean
	Bascule le composant en mode "indéterminé" (spinner infini) si les données ne sont pas prêtes.
	lineCap
	'butt' | 'round' | 'square'
	Définit l'aspect des extrémités du trait. 'round' est essentiel pour un look moderne et organique.
	3.2 Le Problème du "Prop Drilling" et de la Composition
Dans des applications complexes, il est fréquent d'avoir plusieurs cercles animés partageant le même thème. Plutôt que de passer color="#1890ff" à chaque instance, une architecture avancée utiliserait le contexte React (useContext) ou les Design Tokens via une bibliothèque comme Styled-Components ou Emotion. Cependant, pour ce rapport, nous nous concentrerons sur une implémentation pure et autonome pour garantir la portabilité.
3.3 Structure du Composant
Le composant sera divisé en deux couches fonctionnelles :
1. Le Conteneur (Logic Wrapper) : Gère la taille, l'accessibilité, et le positionnement du texte central (pourcentage).
2. Le Moteur SVG (Graphics Engine) : Gère le dessin vectoriel, les rotations, et l'application des filtres.
Cette séparation permet, par exemple, de remplacer le moteur SVG par un moteur Canvas si les performances devenaient critiques (ex: afficher 5000 cercles sur une page), sans changer l'interface publique du composant.
________________
4. Stratégie A : Implémentation via Framer Motion (Le Standard "Vidéo")
Si l'utilisateur a vu une "vidéo" d'une interface moderne (style iOS ou Material Design 3), il a probablement vu des animations gérées par des interpolateurs physiques et non linéaires. CSS pur (transition: all 0.3s ease) est souvent trop rigide. C'est ici qu'intervient Framer Motion, la bibliothèque standard de facto pour l'animation complexe en React.1
4.1 Pourquoi Framer Motion surpasse CSS pur
Framer Motion offre plusieurs avantages décisifs pour notre cas d'usage :
* Spring Physics : Au lieu de définir une durée ("l'animation dure 0.5s"), on définit des propriétés physiques : rigidité (stiffness), amortissement (damping) et masse (mass). Si la progression passe de 0% à 100% puis soudainement à 50%, un ressort gérera ce changement de direction naturellement, en conservant la vélocité, alors qu'une transition CSS créerait un arrêt brutal et artificiel.
* Animation des Attributs : Framer Motion peut animer directement les attributs SVG (attrX, attrY, strokeDasharray) sans passer par des hacks CSS variables, ce qui est plus performant et plus propre sémantiquement.
* Orchestration : Il permet de synchroniser l'apparition du cercle, le remplissage de la barre, et l'apparition du texte central avec des délais (staggerChildren).
4.2 Implémentation Technique Détaillée
Voici le code complet, commenté et typé, intégrant la gestion des erreurs et l'optimisation des performances.


TypeScript




import React, { useMemo } from 'react';
import { motion, Transition, Variants } from 'framer-motion';

/**
* Interface complète des propriétés du composant.
* Suit les conventions de nommage React strictes.
*/
interface AnimatedProgressCircleProps {
 size?: number;
 strokeWidth?: number;
 progress: number; // Valeur entre 0 et 100
 color?: string;
 trackColor?: string;
 isIndeterminate?: boolean; // Mode chargement infini
 showText?: boolean;
}

/**
* Configuration de la physique du ressort (Spring).
* Ces valeurs sont calibrées pour un effet "snappy" mais fluide.
*/
const springTransition: Transition = {
 type: "spring",
 stiffness: 60,  // Tension du ressort : plus haut = plus rapide
 damping: 15,    // Résistance : plus bas = plus d'oscillation
 mass: 1         // Poids : influence l'inertie
};

export const AnimatedProgressCircle: React.FC<AnimatedProgressCircleProps> = ({
 size = 120,
 strokeWidth = 10,
 progress,
 color = "#3b82f6", // Bleu standard
 trackColor = "#e5e7eb", // Gris clair
 isIndeterminate = false,
 showText = true,
}) => {
 // 1. Calculs Géométriques Vectoriels
 // Nous utilisons useMemo pour éviter de recalculer Pi à chaque render,
 // bien que le coût soit trivial, c'est une bonne pratique architecturale.
 const center = size / 2;
 const radius = (size - strokeWidth) / 2;
 const circumference = 2 * Math.PI * radius;

 // Clampage de la valeur de progression entre 0 et 100
 const safeProgress = Math.min(Math.max(progress, 0), 100);
 
 // Calcul de l'offset cible
 const strokeDashoffset = circumference - (safeProgress / 100) * circumference;

 // 2. Définition des Variantes d'Animation
 // Les variantes permettent de définir des états nommés clairs.
 const circleVariants: Variants = {
   hidden: { 
     strokeDashoffset: circumference,
     opacity: 0,
     rotate: -90 
   },
   visible: {
     strokeDashoffset: strokeDashoffset,
     opacity: 1,
     rotate: -90,
     transition: springTransition
   },
   indeterminate: {
     strokeDashoffset: [circumference * 0.9, circumference * 0.2, circumference * 0.9],
     rotate: ,
     transition: {
       rotate: {
         duration: 2,
         repeat: Infinity,
         ease: "linear"
       },
       strokeDashoffset: {
         duration: 1.5,
         repeat: Infinity,
         ease: "easeInOut"
       }
     }
   }
 };

 return (
   <div 
     className="relative flex items-center justify-center"
     style={{ width: size, height: size }}
     role="progressbar"
     aria-valuenow={isIndeterminate? undefined : safeProgress}
     aria-valuemin={0}
     aria-valuemax={100}
   >
     <svg
       width={size}
       height={size}
       viewBox={`0 0 ${size} ${size}`}
       style={{ transform: "rotate(-90deg)", overflow: "visible" }}
     >
       {/* Piste (Track) - Le cercle gris de fond */}
       <circle
         cx={center}
         cy={center}
         r={radius}
         fill="none"
         stroke={trackColor}
         strokeWidth={strokeWidth}
         opacity={0.3}
       />

       {/* Indicateur (Indicator) - Le cercle coloré animé */}
       <motion.circle
         cx={center}
         cy={center}
         r={radius}
         fill="none"
         stroke={color}
         strokeWidth={strokeWidth}
         strokeLinecap="round"
         strokeDasharray={circumference}
         variants={circleVariants}
         initial="hidden"
         animate={isIndeterminate? "indeterminate" : "visible"}
       />
     </svg>
     
     {/* Texte Central Optionnel */}
     {showText &&!isIndeterminate && (
       <div className="absolute inset-0 flex items-center justify-center">
         <span 
           style={{ 
             fontSize: size * 0.25, 
             fontWeight: 'bold', 
             color: '#374151',
             fontFamily: 'system-ui, sans-serif'
           }}
         >
           {Math.round(safeProgress)}%
         </span>
       </div>
     )}
   </div>
 );
};

4.3 Analyse Approfondie du Moteur d'Animation
Ce code illustre plusieurs concepts avancés.
Premièrement, la gestion de l'état Indéterminé. Lorsque isIndeterminate est vrai, le composant bascule dans un mode "spinner". Notez comment nous animons simultanément la rotation du SVG complet (de 0 à 360 degrés) et la longueur du trait (strokeDashoffset). Cette double animation crée l'effet de "ver" (worm effect) qui s'étire et se contracte, caractéristique des loaders Google Material Design. C'est visuellement beaucoup plus engageant qu'une simple rotation linéaire.
Deuxièmement, l'utilisation de strokeLinecap="round". Ce détail semble mineur, mais il est crucial pour l'aspect "premium". Un bout carré (butt) donne un aspect brut et non fini, typique des interfaces des années 2000. Le bout rond suggère une finition organique.
________________
5. Stratégie B : L'Approche "Dégradé Conique" (Pour l'Effet "Wow")
Certaines "vidéos" montrent des cercles avec des queues de comète multicolores ou des dégradés qui suivent la courbe. C'est ici que le SVG standard montre ses limites : il supporte mal les gradients coniques sur un contour (stroke). Pour réaliser cet effet spécifique, nous devons changer de stratégie et utiliser un masque CSS.2
5.1 Architecture des Couches (Layering)
L'astuce consiste à empiler trois éléments :
1. Un conteneur de fond avec un conic-gradient CSS.
2. Un mécanisme de rotation.
3. Un masque (mask) qui découpe le centre pour ne laisser voir qu'un anneau.
Cette technique est illustrée ci-dessous :


  



5.2 Implémentation du Gradient Conique en React
Cette méthode est plus performante pour le GPU car elle n'implique pas de recalcul de vecteurs complexes, seulement de la composition de textures.


TypeScript




import React from 'react';

/**
* Composant GradientSpinner
* Utilise CSS Masking et Conic Gradients pour un effet visuel riche.
*/
export const GradientSpinner: React.FC<{ size?: number }> = ({ size = 100 }) => {
 const borderSize = 8;
 
 return (
   <div 
     style={{
       width: size,
       height: size,
       borderRadius: '50%',
       position: 'relative',
       // Le gradient conique crée l'effet de spectre
       background: `conic-gradient(from 0deg, #ff0080, #7928ca, #ff0080)`,
       // L'animation de rotation standard
       animation: 'spin 1.5s linear infinite',
       // LE SECRET : Le masque radial cache le centre
       // mask-composite est utilisé pour assurer la compatibilité
       WebkitMask: `radial-gradient(farthest-side, transparent calc(100% - ${borderSize}px), black calc(100% - ${borderSize}px))`,
       mask: `radial-gradient(farthest-side, transparent calc(100% - ${borderSize}px), black calc(100% - ${borderSize}px))`
     }}
   >
     <style>{`
       @keyframes spin {
         from { transform: rotate(0deg); }
         to { transform: rotate(360deg); }
       }
     `}</style>
   </div>
 );
};

Cette approche est idéale pour les loaders décoratifs ("spinners") mais moins adaptée pour les barres de progression précises, car contrôler la fin du gradient conique pour représenter "43%" est mathématiquement complexe en CSS pur.
________________
6. Performance Engineering et Optimisation du Rendu
L'un des aspects souvent négligés dans les tutoriels est l'impact de ces animations sur le thread principal du navigateur. Une animation mal codée peut causer des saccades (jank) lors du défilement de la page ou bloquer les interactions utilisateur.
6.1 Le Pipeline de Rendu des Pixels
Pour garantir 60 FPS, nous devons comprendre comment le navigateur transforme le DOM en pixels. Ce processus se déroule en trois étapes majeures :
1. Layout (Mise en page) : Calcul de la géométrie (largeur, hauteur, position). C'est l'étape la plus coûteuse.
2. Paint (Peinture) : Remplissage des pixels (couleurs, ombres, textes).
3. Composite (Composition) : Assemblage des calques (layers) par le GPU.
Règle d'or : Pour une animation fluide, il faut éviter à tout prix de déclencher les étapes de Layout et de Paint à chaque frame.
* Mauvais : Animer width, height, top, left. Cela force le navigateur à recalculer la position de tous les éléments voisins (Reflow).
* Excellent : Animer transform (rotate, scale, translate) et opacity. Ces propriétés sont gérées exclusivement par l'étape Composite et sont accélérées par le GPU.
Dans notre implémentation Framer Motion (Stratégie A), l'animation de stroke-dashoffset est un cas particulier. Bien que ce soit une propriété SVG qui déclenche techniquement du "Paint", les navigateurs modernes (Chrome, Firefox, Safari) ont optimisé ce chemin spécifique pour qu'il soit extrêmement rapide. Cependant, si vous avez 500 cercles sur une page, cela commencera à consommer du CPU.
6.2 Utilisation de la propriété will-change
Pour aider le navigateur, on peut ajouter la propriété CSS will-change: transform ou will-change: stroke-dashoffset sur l'élément animé. Cela avertit le moteur de rendu de préparer une couche séparée (layer promotion) pour cet élément.
Attention : utiliser will-change sur trop d'éléments peut saturer la mémoire VRAM du GPU. À utiliser avec parcimonie.
6.3 Profiling avec React DevTools
Lors du développement, il est crucial d'activer l'option "Highlight updates when components render" dans les React DevTools.
Si votre cercle animé provoque le re-rendu de tout le tableau de bord parent à chaque frame, vous avez un problème de performance majeur.
L'isolation du composant est la clé. Le composant AnimatedProgressCircle doit être une feuille de l'arbre React, ne contenant aucun enfant complexe, pour que ses mises à jour d'état (si gérées localement) n'impactent pas le reste de l'application. Dans notre code Framer Motion, l'animation se fait hors du cycle de rendu React principal (via le système d'animation natif de Framer), ce qui est optimal.
________________
7. Accessibilité (A11y) et Inclusivité
Un composant technique n'est "terminé" que s'il est utilisable par tous. Les animations peuvent poser des problèmes majeurs pour deux groupes d'utilisateurs : ceux utilisant des lecteurs d'écran et ceux souffrant de troubles vestibulaires.
7.1 Préférence de Mouvement Réduit (prefers-reduced-motion)
Certains utilisateurs configurent leur OS pour minimiser les animations afin d'éviter le mal de mer numérique (motion sickness). Nous devons respecter ce choix.
En Framer Motion, cela se gère élégamment avec le hook useReducedMotion.


TypeScript




import { useReducedMotion } from 'framer-motion';

// Dans le composant
const shouldReduceMotion = useReducedMotion();

const variants = {
 visible: {
   strokeDashoffset: targetOffset,
   transition: { 
     // Si mouvement réduit demandé, transition instantanée ou très lente (fondu)
     duration: shouldReduceMotion? 0 : 1.5 
   }
 }
};

7.2 Sémantique ARIA pour les Lecteurs d'Écran
Un SVG est par défaut invisible ou déroutant pour un lecteur d'écran. Nous devons lui donner un sens sémantique.
* Rôle : role="progressbar" indique explicitement la fonction de l'élément.
* Valeurs : aria-valuenow, aria-valuemin, aria-valuemax permettent au logiciel vocal d'annoncer "Progression : 45 pourcent".
* État Indéterminé : Si le cercle est un spinner infini, on ne doit pas utiliser progressbar avec des valeurs, mais plutôt role="status" ou simplement masquer l'élément (aria-hidden="true") si un texte "Chargement..." est présent ailleurs.
________________
8. Intégration Avancée : Hooks et Composition
Pour aller plus loin, imaginons que la couleur du cercle doive changer dynamiquement en fonction de la progression (vert à 100%, rouge à 10%). Coder cette logique dans le composant visuel viole le principe de responsabilité unique. Nous devrions extraire cette logique dans un Hook.
8.1 Le Hook useProgressColor


TypeScript




/**
* Hook utilitaire pour interpoler la couleur en fonction du score.
* Utilise une échelle HSL pour une transition fluide.
*/
const useProgressColor = (value: number) => {
 // Vert (120) à Rouge (0)
 // On mappe 0-100 vers 0-120
 const hue = (value / 100) * 120; 
 return `hsl(${hue}, 80%, 50%)`;
};

En intégrant ce hook, notre composant devient "intelligent" visuellement sans alourdir sa logique interne de rendu.
8.2 Distribution sous forme de Bibliothèque
Si ce composant est destiné à être utilisé dans plusieurs projets (Design System), il doit être compilé.
* Exports : Il faut exporter non seulement le composant AnimatedProgressCircle, mais aussi l'interface AnimatedProgressCircleProps pour que les consommateurs puissent typer leurs données.
* Peer Dependencies : react, react-dom et framer-motion doivent être déclarés comme peerDependencies dans le package.json pour éviter de dupliquer ces bibliothèques dans le bundle final de l'application hôte.
________________
9. Conclusion : Au-delà du Cercle
La requête initiale, simple en apparence, nous a menés à travers les couches profondes de l'ingénierie frontend. Nous avons vu que réaliser un "cercle animé comme sur la vidéo" est un exercice de synthèse entre :
1. La Géométrie Vectorielle : Comprendre le cercle non comme une forme, mais comme un chemin mathématique manipulable.
2. La Physique de l'Animation : Rejeter la linéarité pour embrasser les modèles de ressorts qui imitent le monde réel.
3. L'Architecture Logicielle : Structurer le code pour qu'il soit maintenable, typé et performant.
4. L'Éthique du Développement : Garantir que l'expérience est accessible à tous, indépendamment des capacités physiques ou matérielles.
Le code fourni dans la Stratégie A (Framer Motion) représente l'état de l'art actuel pour des applications React professionnelles. Il est prêt à être copié, adapté et déployé en production. Pour des besoins purement décoratifs et ultra-légers, la Stratégie B (CSS Gradient) reste une alternative valide.
En maîtrisant ces techniques, vous ne créez pas seulement des "cercles qui tournent" ; vous créez une interface vivante, réactive et professionnelle qui inspire confiance à l'utilisateur final. C'est là toute la différence entre le code et l'ingénierie.
Works cited
1. React animation — Transforms, keyframes & transitions | Motion, accessed on January 3, 2026, https://motion.dev/docs/react-animation
2. My Struggle to Use and Animate a Conic Gradient in SVG - CSS-Tricks, accessed on January 3, 2026, https://css-tricks.com/my-struggle-to-use-and-animate-a-conic-gradient-in-svg/
3. How to create an SVG gradient loading spinner | Ben Ilegbodu, accessed on January 3, 2026, https://www.benmvp.com/blog/how-to-create-circle-svg-gradient-loading-spinner/